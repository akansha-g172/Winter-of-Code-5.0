[
  {
    "name": "OWASP Nest",
    "developer": "OWASP Nest",
    "desc": "Problem Statement\n\nOWASP Nest is a comprehensive platform designed to enhance collaboration and contribution within the OWASP community. The application serves as a central hub for exploring OWASP projects and ways to contribute to them, empowering contributors to find opportunities that align with their interests and expertise.\n\nFocus Areas\n\nWe have multiple focus areas:\nBackend (Python, Django, Ninja, Strawberry)\nFrontend (TypeScript, Next.js, React, TailwindCSS)\nNestBot (Slack API, Python, OpenAI API)\n\nStudent Contribution Guide (Idea Page)\n\nAny open and available for work issues from https://github.com/OWASP/Nest/issues\nWe're accepting new issues too (subject to approval). If accepted we'll add a WoC 5.0 label for easy search and will help students to come up with meaningful and realistic projects/milestones.",
    "techstack": [
      "Python",
      "Django",
      "TypeScript",
      "React",
      "Next.js",
      "TailwindCSS",
      "GraphQL",
      "Docker",
      "AWS"
    ],
    "github": "https://github.com/OWASP/Nest",
    "mentors": [
      {
        "name": "Arkadii Yakovets",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/arkid15r/",
          "discord": "arkid15r",
          "email": "arkadii.yakovets@owasp.org",
          "twitter": ""
        }
      },
      {
        "name": "Kateryna Golovanova",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kate-golovanova/",
          "discord": "",
          "email": "kateryna.golovanova@owasp.org",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Quizora",
    "developer": "Development Society AEC",
    "desc": "• Problem Statement:\nTraditional learning and assessment methods often lack engagement and real-time feedback, leading to lower student participation. \"Rapid Quiz Relay\" solves this by introducing a gamified, fast-paced environment where users can test their knowledge under time constraints, fostering competitive learning.\n• Focus Areas:\no Backend API Development & Real-time data handling.\no UI/UX improvements for seamless quiz transitions.\no Performance optimization for concurrent users.\no Gamification logic (Leaderboards, Relay timers).\n• Student Contribution Guide (Idea Page):\nStudents will work on enhancing the quiz engine, implementing new question types, and optimizing the relay timer logic.\n\no Milestone 1: Setup environment and fix minor UI bugs.\no Milestone 2: Implement user authentication and profile tracking.\no Milestone 3: Develop real-time leaderboard and \"Relay\" mode features.",
    "techstack": ["HTML", "CSS", "JavaScript", "TypeScript", "React", "Convex"],
    "github": "https://github.com/Nilam-Kumari-Mahato/Quizora",
    "mentors": [
      {
        "name": "Asif Qamar",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/asif-qamar",
          "discord": ".gamedotexe",
          "email": "asifqamar1832004@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Nilam Kumari Mahato",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/nilam-kumari-mahato-5a2710307",
          "discord": "Nilam_Mahato",
          "email": "nilamkumarimahato10@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Prerna Priya",
        "socials": {
          "linkedin": "www.linkedin.com/in/prerna-priya-ab3581329",
          "discord": "yuna086841",
          "email": "prerp.6299@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Arnab chatterjee",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/arnab-chatterjee-905ab3219/",
          "discord": "arnabch20k",
          "email": "arnabchatterjee.ac.2@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Amartya Chowdhury",
        "socials": {
          "linkedin": "https://linkedin.com/in/amartya-chowdhury",
          "discord": "@paraxius",
          "email": "amartyachowdhury4@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Swarup Goswami",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/swarup-goswami-7a9444311",
          "discord": "swarup_goswami",
          "email": "goswamiswarup97@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Orycon",
    "developer": "Open Source Chandigarh",
    "desc": "Orcyon is a comprehensive platform built with Next.js, Node.js, and MongoDB to help college societies plan, organize, and execute events with ease. It streamlines everything from content creation and social media scheduling to logistics coordination and real-time attendance tracking. Designed for Students, Team Admins, and specialized teams, the system provides a centralized and intuitive workspace that enhances collaboration, automates repetitive tasks, and improves the overall efficiency of event management.\n\nDetailed Project Description\nProblem Statement\nCollege societies often struggle to manage events efficiently due to scattered tools for planning, content creation, social media, logistics, and attendance tracking. This Event Management System solves that problem by unifying all workflows into a single platform, enabling teams to collaborate smoothly while giving students an easy way to register and mark attendance.\nAlthough the system greatly improves coordination and execution, it currently lacks features like advanced analytics, automated social media publishing, and integrated payment handling. These enhancements are planned for future releases to further boost efficiency and scalability.\nFuture Focus Areas:\n• Backend Logic: Implementing advanced modules such as automated attendance processing, documentation generation, post-event analytics, and improved role-based access across teams.\n• UI/UX: Enhancing dashboards for each team, adding intuitive scheduling interfaces, improving the idea management flow, and refining the overall navigation for a smoother multi-team experience.\n• Technical Writing: Creating clear documentation for team workflows—covering event planning, content creation, social media scheduling, logistics management, and onboarding guides for new users.\nStudent Contribution Guide\nThe project will have two phases. Completing Phase 1 is required before moving to Phase 2, while Phase 2 is optional and can be completed if time permits.\nPhase 1: Implementation of New Core Features\nIn this phase, the student is expected to focus on backend and frontend development to deliver core system improvements. Features include:\n1. Attendance Automation Enhancements: Implement improved logic for automatic attendance generation, walk-in detection, and streamlined QR-based verification.\n2. Social Media Scheduler Improvements: Build features for calendar-based scheduling, automatic reminders, and version control for social posts (text, image, video).\n3. Content Documentation Generator: Develop the automated documentation generation tool that compiles event details, speeches, and write-ups into structured reports.\n4. Meeting Scheduler Expansion: Add multi-team invite support, RSVP tracking, and integration with common calendar formats.\n5. Idea Box Upgrades: Implement voting, commenting, and category tagging, along with a cleaner moderation workflow for Team Admins.\n6. Logistics & Feedback Analyzer: Enhance the analytics pipeline to process event feedback and provide post-event summaries using charts, sentiment indicators, or basic insights.\n7. Hiring Portal Development: Develop the hiring portal with options to mark candidates as Selected, Maybe, or Rejected, and the ability to transfer applicants between teams.\nPhase 2: Technical Writing and Knowledge Resources\nThis phase focuses on creating educational and onboarding materials for new users and teams across the system.\n1. Team Workflow Guides: Write clear documentation explaining how each team (Organising, Content, Social Media, Logistics, Admin) should use the system for their daily tasks.\n2. Feature Tutorials: Produce step-by-step guides for modules built in Phase 1—such as scheduling posts, generating documentation, running meetings, or analyzing feedback.\n3. Event Management Handbook: Create a structured learning section with best practices for planning and executing events using the platform.\n4. Student Onboarding Material: Write simple, visual guides showing students how to log in, register for events, and mark attendance via QR codes.",
    "techstack": [
      "Next.js",
      "React",
      "Node.js",
      "Express.js",
      "MongoDB",
      "Prisma",
      "Turborepo",
      "Git",
      "GitHub Actions"
    ],
    "github": "https://github.com/Open-Source-Chandigarh/orycon",
    "mentors": [
      {
        "name": "Angad Sudan",
        "socials": {
          "linkedin": "https://linkedin.com/in/angadsudan/",
          "discord": "@angadsudan",
          "email": "angadsudan453@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Ayush Chauhan",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/ayuch",
          "discord": "@bakayu",
          "email": "ayu.0067abc@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "gitx",
    "developer": "Open Source Chandigarh",
    "desc": "gitx is a Terminal User Interface (TUI) built with Golang to help you learn and interact with git. It provides a visual way to handle common git commands, making it easier for both beginners and experienced users to manage their repositories without leaving the terminal. Tech Stack • Language: Golang • Frameworks: Bubbletea, Hugo • Tools: Git, Github Actions, Hugo for docs Detailed Project Description 1. Problem Statement: Beginners often struggle with git commands when getting started with git and version control, gitx was developed to solve this very problem and provide a platform inside the terminal to provide a beginner friendly interface, which provides an abstraction over git, takes away the complexity and allows user to learn and use git more easily. While gitx provides a great overview of git repositories, currently it lacks granular control for advanced workflows (like staging specific lines) and the documentation on tutorials and guides is also lacking. 2. Focus Area: • Backend Logic: Implementing new features to add more git operations to the Terminal User Interface. • UI/UX: Enhancing the visual diff viewer and adding interactive elements. • Technical Writing: Writing documentation for the 'Learn' section on how to use the TUI. 3. Student Contribution Guide: The project will have 2 phases, completing the first is necessary to move onto the second phase, while the second phase would be optional and can be completed if the time allows. Phase 1: Implementation of New Core Features In this phase, the student would be expected to focus on coding and delivering the features listed on gitxtui.github.io/docs/contribute/roadmap; Also listed below: • Repository Initialization: Implement the ability to initialize a new Git repository (like git init) directly from the startup screen or command menu if one doesn't exist. • Safety Warnings: Add a confirmation and warning system for sensitive actions, such as initializing a repository in a non-empty directory or home folder. • Improved Visual Diff Viewer: Refactor the MainPanel view to provide a clearer, syntax-highlighted, or side-by-side representation of file changes. • Interactive Staging: Develop the functionality to select and stage specific lines or code hunks interactively from within the diff viewer. • Custom Keybindings: Update configuration file logic to allow users to remap keybindings (currently hardcoded in keys.go). Phase 2: Technical Writing and Education Resources This phase focuses on documenting and helping new users learn git through gitx. • 'Learn' Section Content: specific hands-on document series explaining how to use the TUI for various Git workflows. • Feature Tutorials: Comprehensive guides and examples for the new features built in Phase 1 (e.g., 'How to interactively stage changes').",
    "techstack": ["Golang", "Bubbletea", "Hugo", "Git", "Github Actions"],
    "github": "https://github.com/gitxtui/gitx",
    "mentors": [
      {
        "name": "Ayush Chauhan",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/ayuch",
          "discord": "@bakayu",
          "email": "ayu.0067abc@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Pyre",
    "developer": "Open Source Chandigarh",
    "desc": "Pyre is a custom-built, modular 3D graphics engine designed to bridge the gap between theoretical graphics programming and practical game engine development. It focuses on clean architecture, exposing the raw OpenGL pipeline while managing complexity through robust design patterns like ECS (Entity Component System).\n\nDetailed Project Description\nProblem Statement Many computer science students learn graphics theory—the mathematics of drawing a single triangle—but never cross the chasm to building a system robust enough to be called an \"engine.\"\nSolution Pyre addresses this by offering a robust codebase that exposes students to the raw OpenGL pipeline. It currently supports advanced features like Deferred-style architecture preparation, Stencil buffers, Framebuffers, Skyboxes, and Blinn-Phong lighting.\nFocus Areas:\n• Engine Tooling: Building in-engine GUI (ImGui) tools for runtime debugging and scene manipulation.\n• Mathematics: Upgrading core systems from Euler angles to Quaternions.\n• Visual Fidelity: Implementing advanced post-processing (Gaussian Blur, Edge Detection) and lighting visualization.\n• Robustness: Creating error-safe asset loading pipelines to handle missing files gracefully.\nStudent Contribution Guide\nWe have categorized contribution tasks into three tiers based on complexity and the required background in Linear Algebra and C++.\nTier 1: Beginner / Warm-up Focus: Input handling, Game Logic, and Basic Visual Helpers.\n• Debug Toggle System: Implement a runtime toggle (e.g., binding the H key) to show/hide helper objects like light diamonds that currently clutter the view.\n• Camera Speed Control: Implement dynamic camera speed adjustment (e.g., pressing + / - to increase/decrease speed) to assist with navigating large scenes vs inspecting details.\n• Expanded Light Visualizers: Implement wireframe gizmos for Directional Lights (lines indicating sun direction) and Spotlights (wireframe cones indicating influence and cutoff).\nTier 2: Intermediate (The 'Editor' Features) Focus: Library Integration, UI, and Buffer Manipulation.\n• ImGui Integration (Primary Focus): Integrate the Dear ImGui library into the render loop to create a basic 'Inspector' window for changing light colors, intensity, and positions in real-time.\n• Advanced Post-Processing: Implement Gaussian Blur (requires multi-pass rendering) and Edge Detection (Sobel Operator) for stylized/outline rendering.\n• Asset Loader Hardening: Improve the Assimp model loader to detect missing texture files, log a warning, and load a default 'checkerboard' texture instead of crashing or showing errors.\nTier 3: Advanced (Math & Algorithms) Focus: Linear Algebra and Complex Rendering Pipelines.\n• Quaternion Camera System: Upgrade the camera class from Euler Angles to Quaternions to eliminate Gimbal Lock and allow for true 6-DOF (Degree of Freedom) movement.\n• Shadow Mapping: Implement the first pass of a Shadow Mapping system by rendering scene depth from the Light's perspective to a Framebuffer and using it to determine occluded fragments.",
    "techstack": [
      "C++",
      "OpenGL",
      "GLFW",
      "GLM",
      "Assimp",
      "stb_image",
      "CMake",
      "Dear ImGui"
    ],
    "github": "https://github.com/Open-Source-Chandigarh/pyre",
    "mentors": [
      {
        "name": "Dhruv Ranger",
        "socials": {
          "linkedin": "dhruv-ranger-716564383",
          "discord": "dhruv0154",
          "email": "dhruvranger97@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "WallGodds Web",
    "developer": "WallGodds",
    "desc": "A modern wallpaper website offering high-quality wallpapers for mobile, tablet, and desktop devices. Features include user uploads, categorization, and profile management.\n• Problem Statement: Many existing wallpaper platforms lack proper screen-size categorization and often overwhelm users with cluttered interfaces. WallGodds addresses this by offering a clean, minimal, and intuitive experience for browsing wallpapers across mobile, tablet, and desktop, while also allowing users to freely upload their own collections.\n\n• Focus Areas: UI/UX enhancement, performance optimization, and backend API development.\n\n• Student Contribution Guide (Idea Page): Contributors are encouraged to work on issues within our core focus areas or propose fresh, creative ideas. Collaboration with designers and developers is highly welcomed as we continue building a smoother, smarter, and more engaging platform together.",
    "techstack": ["React", "Firebase"],
    "github": "https://github.com/WallGodds/WallGodds-Web",
    "mentors": [
      {
        "name": "Parnab Bagchi",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/parnab-bagchi-072966251/",
          "discord": "Parnab_03",
          "email": "pb7439578071@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Soumik Ghosh",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/parnab-bagchi-072966251/",
          "discord": "soumikghosh_999",
          "email": "soumikghosh09072004@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "WallGodds App",
    "developer": "WallGodds",
    "desc": "WallGodds is reimagined for mobile — fast, clean, and loaded with stunning high-res wallpapers for every screen. It's more than an app — it's your personal visual canvas, made for those who style their screen with every swipe.\n\n• Problem Statement: Applying wallpapers directly from the WallGodds website on mobile is often a long, repetitive process. Our goal is to simplify this through a dedicated mobile app that provides a seamless wallpaper experience while still allowing users to freely upload and share their own collections.\n\n• Focus Areas: UI/UX enhancement, performance optimization, and backend API development.\n\n• Student Contribution Guide (Idea Page): Contributors are encouraged to work on issues within our core focus areas or propose fresh, creative ideas. Collaboration with designers and developers is highly welcomed as we continue building a smoother, smarter, and more engaging platform together.",
    "techstack": ["Kotlin", "Compose", "Firebase"],
    "github": "https://github.com/WallGodds/WallGodds-App",
    "mentors": [
      {
        "name": "Sayan Basak",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/sayan-basak003/",
          "discord": "cyanb",
          "email": "sayanbasak42@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Shankhadeep Paria",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/shankhadeepparia/",
          "discord": "shankyy69",
          "email": "pariashankhadeep@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "GBasis: Arbitrary-order Overlap Integrals",
    "developer": "QC-Devs",
    "desc": "Problem Statement/Description\n\nAdd functionality to the GBasis library for arbitrary-order overlaps. One motivation of this is to support the evaluation of the intracule (the distribution function for the interelectronic distance) and the extracule (the distribution function for the center-of-mass of electron pairs).\n\nWhat will you do?\n\nYour main focus will be to add functionality for the overlaps of arbitrarily many Gaussian basis functions. It is important to include screening, as otherwise the evaluations can be quite expensive. An important application, which should be supported with an appropriate API, is evaluation of the intracule and extracule. This is possible because, using tricks popularized by Beylkin and Monzon, almost any interparticle repulsion can be written as a sum of Gaussians. This would include the (many-body) interactions associated with nucleons and other types of codeensors and cohesors. This is a place where some creativity can be exercised, as innovative new algorithms and improved fits are being consistently proposed.\n\nFocus Areas\n• Implementation and testing of numerical algorithms.\n• Development of API (porcelain) to support the use of the new functionality.\n• Writing documentation and tutorial notebooks.\n\nExpected Outcomes\n1. Implement the overlap for an arbitrary number of (contracted, Cartesian or spherical) Gaussian basis functions.\n2. Add support for screening, with appropriate default parameters.\n3. Add functionality for evaluating the intracule and extracule.\n4. Utilities for computing positive integer powers of the electron density and relevant density matrices.\n5. Support for (near) arbitrary interparticle repulsion integrals. This uses the aforementioned trick of Beylkin and Monzon.\n6. Write comprehensive tests and documentation for all new functionality.\n7. Write tutorial Jupyter notebooks that show how to use the new functionality.",
    "techstack": ["Python", "GitHub Actions", "Object-oriented programming"],
    "github": "https://github.com/theochem/gbasis",
    "mentors": [
      {
        "name": "Marco Martinez-Gonzalez",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "mmq870630_at_gmail_dot_com",
          "twitter": "marco-2023"
        }
      },
      {
        "name": "Farnaz Heidar-Zadeh",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "farnaz_dot_heidarzadeh_at_queensu_dot_ca",
          "twitter": "FarnazH"
        }
      },
      {
        "name": "Esteban Vöhringer-Martinez",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "estebanvohringer_at_qcmlab_dot_com",
          "twitter": "evohringer"
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Better Linking Between libcint with GBasis",
    "developer": "QC-Devs",
    "desc": "Project Statement/Description\n\nGBasis uses libcint as a back end for efficient integral evaluation. Unfortunately, the default installation of GBasis (with PyPI) doesn't include libcint, and installation from source is not easy for some users. The primary goal of this project is to fix this. The secondary, subsidiary, goal is to provide better support for the very rich set of integrals that libcint supports.\n\nWhat will you do?\n\nYour main focus will be to prepare a release of GBasis that includes libcint for PyPI. We want to support Windows, Linux, and Mac. Note that when we say libcint this includes libcint (generic C++ library) and its high-performance variant pyscf, for hardware platforms that support it. There might be multiple ways to do this, using, for example, Meson. We are agnostic as to the way it is done, but we note that (a) compiling libcint can be hairy and (b) we want an automated workflow so that updating GBasis is easy and new versions of libcint are easily supported.\n\nFocus Areas\n• DevOps automatic building, testing, and releasing of Python packages with compiled back ends.\n• Development of API (porcelain) to support the use of the additional integrals from libcint.\n• Writing documentation and tutorial notebooks.\n\nExpected Outcomes\n1. It becomes possible to pip install GBasis with the libcint integral engine.\n2. More (most?) of the integrals in libcint are accessible from GBasis. (This is basically wrapping more integrals. It isn't always trivial. #149)\n3. Write comprehensive tests and documentation for all new functionality.\n4. Write tutorial Jupyter notebooks that show how to use the new functionality.",
    "techstack": ["C++", "Python", "OOP", "DevOps"],
    "github": "https://github.com/theochem/gbasis",
    "mentors": [
      {
        "name": "Marco Martinez-Gonzalez",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "mmq870630_at_gmail_dot_com",
          "twitter": "marco-2023"
        }
      },
      {
        "name": "Michelle Richer",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "michellericher93_at_gmail_dot_com",
          "twitter": "msricher"
        }
      },
      {
        "name": "Toon Verstraelen",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "toon_dot_verstraelen_at_ugent_dot_be",
          "twitter": "tovrstra"
        }
      },
      {
        "name": "Paul Ayers",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "ayers_at_mcmaster_dot_ca",
          "twitter": "PaulWAyers"
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "GBasis: 2-electron integrals",
    "developer": "QC-Devs",
    "desc": "Problem Statement/Description\n\nAdd functionality to the GBasis library for evaluating 2-electron integrals, including non-Coulomb repulsions. The current Python implementation is very slow, but it also uses a very inefficient algorithm. A more efficient algorithm, combining the Obara-Saika and Head-Gordon-Pople recurrences, would fix this issue. One advantage of having this coded in (pure) Python is that it makes it easy to explore new screening methods, exploit sparsity, and include unconventional integrals (e.g., screened Coulomb interactions). Here is a good introduction to Gaussian integral evaluation, which can help you get your bearings without overwhelming you with (important!!) details.\n\nWhat will you do?\n\nYour main focus will be to (re)implement the 2-electron integrals in GBasis using the algorithm in the notes. This is important partly because it seems we may have a bug in the integrals for high angular momentum (cf. #216) and because the current implementation is painfully slow. It is very helpful for many people to have a pure Python implementation of the 2-electron integrals because, while it will always be (relatively) slow, it allows more flexibility for development of new algorithms and facilitates cross platform code interoperability. In addition, in many cases integral evaluation is not the performance bottleneck.\n\nThe key steps will be to: 1. Understand the recursive evaluation of Gaussian integrals. 2. Implement the key recurrences. (vertical, horizontal, electron-transfer) 3. Apply those recurrences in sequence to evaluate the 2-electron integrals. 4. Write functions for different 'initializations' of the Boys function to support different types of 2-electron integrals.\n\nFocus Areas\n• Implementation and testing of numerical algorithms.\n• Development of API (porcelain) to support the use of the new functionality.\n• Writing documentation and tutorial notebooks.\n\nExpected Outcomes\n1. Implement the recursive evaluation of 2-electron integrals into GBasis using the algorithm in the notes. This requires implementing several different recurrences, which are the 'building blocks' for the algorithm as a whole.\n2. Implement several different 'generalized Boys functions' so that multiple types of 2-electron integrals are supported.\n3. Write comprehensive tests and documentation for all new functionality.\n4. Write tutorial Jupyter notebooks that show how to use the new functionality.",
    "techstack": ["Python", "OOP"],
    "github": "https://github.com/theochem/gbasis",
    "mentors": [
      {
        "name": "Paul Ayers",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "ayers_at_mcmaster_dot_ca",
          "twitter": "PaulWAyers"
        }
      },
      {
        "name": "Marco Martinez-Gonzalez",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "mmq870630_at_gmail_dot_com",
          "twitter": "marco-2023"
        }
      },
      {
        "name": "Fanwang Meng",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "fanwang_dot_meng_at_queensu_dot_ca",
          "twitter": "FanwangM"
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "MIXXX",
    "developer": "MIXXX",
    "desc": "Spin-Up/Spin-Down Effect on Play/Pause\nA real turntable cannot instantly start and stop a track. The tempo increases gradually when pressing playand spins down after pressing pause. This effect has been implemented in various controller mappings but isnot yet available for GUI controls and keyboard. The project aims to review existing mapping solutions andmove them into the C++ domain of Mixxx.\nDetails: https://github.com/mixxxdj/mixxx/issues/15071\n\nFader Start\nRadio DJs are used to start the tracks with the fader only. There shall be no need for touchingplay/cue/pause. This feature has been implement in various controller mappings but is not yet available forGUI controls. The project aims to review existing mapping solutions and move them into the C++ domain ofMixxx.\nDetails: https://github.com/mixxxdj/mixxx/issues/5587\n\nReverb Band Pass Effect\nMixxx has an effect rack with a couple of built-in effects. We have a request to integrate a band pass filterwith the reverb effect. The work requires to analyse how the reverb and the band pass filter works, integratecode and tweak the default parameters for a pleasant effect.\nDetails: https://github.com/mixxxdj/mixxx/issues/12504\n\nFormant Effect\nMixxx has an effect rack with a couple of built-in effects. This project aims to add a Formant shift effect. AFormant effect can be used to make vocals like chipmunks without changing the pitch. The work requiresreview of existing Formant filters and implementing it in the Mixxx code base. Details:\nhttps://github.com/mixxxdj/mixxx/issues/9300",
    "techstack": ["First-year programming", "JS", "C++"],
    "github": "https://github.com/mixxxdj/mixxx",
    "mentors": [
      {
        "name": "Daniel Schürmann",
        "socials": {
          "linkedin": "",
          "discord": "daschuer9032",
          "email": "daschuer@mixxx.org",
          "twitter": ""
        }
      },
      {
        "name": "Armaan Chowfin",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "by6charm@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "libcupsfilters",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/libcupsfilters",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "cups-filters",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/cups-filters",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "cpdb-libs",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/cpdb-libs",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "cpdb-backend-cups",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/cpdb-backend-cups",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "cups-snap",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/cups-snap",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "libppd",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/libppd",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "pappl-retrofit",
    "developer": "Open Printing",
    "desc": "Complete CI testing for OpenPrinting projects\n\nProblem statement\nAs the software components we develop at OpenPrinting are an essential part of the operatingsystem infrastructure, we want to have a solid CI testing of each commit to our GitHubrepositories. CUPS (“cups” repository for 2.x) has already excellent CI done by Michael Sweet,consisting of GitHub actions/workflows which automatically apply static analysers, build andexecution tests on different architectures and distros, ... This we want to have also in the otherprojects on OpenPrinting.\n\nFocus Areas\n● Creating GitHub workflows and make them triggered with commits\n● Scripting to run analysers, build code, run test programs ...\n● C programming to write test programs\n\nStudent Contribution Guide\nThe contributor will study at first the CI done by Michael Sweet, especially in OpenPrinting’sCUPS repository but also in the repositories of Michael’s personal GitHub, especially PAPPL,PDFio, ... Michael is an excellent example here.Then they will check the repository of the OpenPrinting project they are working on andimplement the same functionality there. One part is to overtake and adapt the scripting, which isprobably the smaller part, the other is to add extra tests to the “make check” run which will getexecuted after each build test.Each added test functionality the contributor will have to test, and make sure that if the codeunder test is OK, the tests pass and in case of the tests failing to check whether it is their fault ora bug in the code under test (which they report).",
    "techstack": ["C", "Shell", "Git", "Github Actions/Workflows", "Static Analysers and similar tools"],
    "github": "https://github.com/OpenPrinting/pappl-retrofit",
    "mentors": [
      {
        "name": "Till Kamppeter",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/kamppetertill/",
          "discord": "tillkamppeter",
          "email": "till.kamppeter@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "go-avahi",
    "developer": "Open Printing",
    "desc": "Adding Fuzzing Support to go-avahi in OpenPrinting\n\nProblem statement\nThe go-avahi project provides Go bindings for the Avahi/mDNS/DNS-SD stack and is used fornetwork service discovery functionality within the OpenPrinting ecosystem. It acts as a bridgebetween Go applications and the underlying Avahi daemon through D-Bus.\nCurrently, go-avahi has no fuzz testing, limited test coverage, and several input-handling pathsmay fail in unexpected ways for malformed or adversarial input. For this project,, fuzzing isespecially important to uncover crashes, panics, and edge cases.\n\nThis project aims to develop a comprehensive fuzzing setup for go-avahi, improve testcoverage, and integrate the project into the OSS-Fuzz ecosystem to enable continuous,long-term fuzz testing.\n\nFocus Areas\n● Identify suitable fuzzing targets in go-avahi\n● Write Go fuzz tests for identified functions\n● Add mocks if needed to test\n● Prepare build scripts and configuration for OSS-Fuzz\n● Validate that fuzzers run in the OSS-Fuzz environment\n● Submit a PR to OSS-Fuzz\n\nStudent Contribution Guide\nThe contributor will begin by reviewing how fuzzing is already set up in the OpenPrinting/fuzzingrepository and how other OpenPrinting projects are integrated into OSS-Fuzz. The contributorwill study the structure of go-avahi, select entry points that benefit from fuzzing, and add fuzztests using Go's built-in fuzzing engine. They will introduce mocks if required to make fuzzingreproducible. After fuzzers work locally, the contributor will create the necessary OSS-Fuzz filesand submit an integration. Throughout the project, they will review crashes, minimize test cases,and collaborate with maintainers to address issues found by the fuzzers.",
    "techstack": ["Go", "FUZZ Testing", "Security"],
    "github": "https://github.com/OpenPrinting/go-avahi",
    "mentors": [
      {
        "name": "Mohammed Imaduddin",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/mdimado/",
          "discord": "",
          "email": "mdimad005@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "fuzzing",
    "developer": "Open Printing",
    "desc": "Adding Fuzzing Support to go-avahi in OpenPrinting\n\nProblem statement\nThe go-avahi project provides Go bindings for the Avahi/mDNS/DNS-SD stack and is used fornetwork service discovery functionality within the OpenPrinting ecosystem. It acts as a bridgebetween Go applications and the underlying Avahi daemon through D-Bus.\nCurrently, go-avahi has no fuzz testing, limited test coverage, and several input-handling pathsmay fail in unexpected ways for malformed or adversarial input. For this project,, fuzzing isespecially important to uncover crashes, panics, and edge cases.\n\nThis project aims to develop a comprehensive fuzzing setup for go-avahi, improve testcoverage, and integrate the project into the OSS-Fuzz ecosystem to enable continuous,long-term fuzz testing.\n\nFocus Areas\n● Identify suitable fuzzing targets in go-avahi\n● Write Go fuzz tests for identified functions\n● Add mocks if needed to test\n● Prepare build scripts and configuration for OSS-Fuzz\n● Validate that fuzzers run in the OSS-Fuzz environment\n● Submit a PR to OSS-Fuzz\n\nStudent Contribution Guide\nThe contributor will begin by reviewing how fuzzing is already set up in the OpenPrinting/fuzzingrepository and how other OpenPrinting projects are integrated into OSS-Fuzz. The contributorwill study the structure of go-avahi, select entry points that benefit from fuzzing, and add fuzztests using Go's built-in fuzzing engine. They will introduce mocks if required to make fuzzingreproducible. After fuzzers work locally, the contributor will create the necessary OSS-Fuzz filesand submit an integration. Throughout the project, they will review crashes, minimize test cases,and collaborate with maintainers to address issues found by the fuzzers.",
    "techstack": ["Go", "FUZZ Testing", "Security"],
    "github": "https://github.com/OpenPrinting/fuzzing",
    "mentors": [
      {
        "name": "Mohammed Imaduddin",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/mdimado/",
          "discord": "",
          "email": "mdimad005@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "go-mfp",
    "developer": "Open Printing",
    "desc": "Implementing WS-Scan support to go-mfp in OpenPrinting\n\nProblem statement\nCurrently, the go-mfp project, aimed to implement a full-featured behaviour-accurate MFPsimulator together with collection of the MFP testing/validation/troubleshooting tools, lacks thesupport of WS-Scan protocol. We already have eSCL, partially implemented IPP, virtual USBMFP simulation (IPP over USB and legacy 7/1/1 USB printer), but WS-Scan support is not yetcompleted.\n\nFocus Areas\n● Complete full-featured, specification-based WS-Scan protocol implementation\n● Integrate this part with the whole project\n● Provide a good test coverage for the newly added code\n\nStudent Contribution Guide\nWS-Scan protocol is technically and semantically similar to the eSCL protocol, which is alreadyimplemented. The contributor will study the existing eSCL implementation and create WS-Scanimplementation, using the similar architectural approach. The ability to read and understandtechnical specifications is strongly required, because we need the high-quality, reference-classprotocol implementation, strictly based on the protocol specification, published by Microsoft.",
    "techstack": ["Go"],
    "github": "https://github.com/OpenPrinting/go-mfp",
    "mentors": [
      {
        "name": "Alexander Pevzner",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/alexander-pevzner-6046161/",
          "discord": "",
          "email": "pzz@apevzner.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "go-mfp escl",
    "developer": "Open Printing",
    "desc": "Implementing WS-Scan support to go-mfp in OpenPrinting\n\nProblem statement\nCurrently, the go-mfp project, aimed to implement a full-featured behaviour-accurate MFPsimulator together with collection of the MFP testing/validation/troubleshooting tools, lacks thesupport of WS-Scan protocol. We already have eSCL, partially implemented IPP, virtual USBMFP simulation (IPP over USB and legacy 7/1/1 USB printer), but WS-Scan support is not yetcompleted.\n\nFocus Areas\n● Complete full-featured, specification-based WS-Scan protocol implementation\n● Integrate this part with the whole project\n● Provide a good test coverage for the newly added code\n\nStudent Contribution Guide\nWS-Scan protocol is technically and semantically similar to the eSCL protocol, which is alreadyimplemented. The contributor will study the existing eSCL implementation and create WS-Scanimplementation, using the similar architectural approach. The ability to read and understandtechnical specifications is strongly required, because we need the high-quality, reference-classprotocol implementation, strictly based on the protocol specification, published by Microsoft.",
    "techstack": ["Go"],
    "github": "https://github.com/OpenPrinting/go-mfp/tree/master/proto/escl",
    "mentors": [
      {
        "name": "Alexander Pevzner",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/alexander-pevzner-6046161/",
          "discord": "",
          "email": "pzz@apevzner.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "go-mfp IEEE",
    "developer": "Open Printing",
    "desc": "Adding the legacy IEEE-1284 printers support to go-mft in OpenPrinting\n\nProblem statement\nCurrently, the go-mfp simulator already has very basic support of the legacy USB 7/1/1 printeremulation. However, it doesn’t somehow interpret the data sent to the emulated printer anddoesn’t provide any response (as 7/1/2 devices should do).\nThe project goal is to implement the Go io.Reader (for 7/1/1 devices) and Go io.ReadWriter thatconsumes raw data bytes, sent to the emulated printer and able to properly identify documentformat being sent (i.e., PostScript, PDF, PCL5, ESC/P, ...) and based on that identificationproperly detect the document or page boundaries (for example, PostScript and PDF documentsare terminated by the Ctrl-D character, ESC/P and PCL5 may use end-of-page character etc).\nHaving that implemented we can add saving documents to file for further analysis andtroubleshooting and document rendering for printed image evaluation.\nAlso, the bidirectional (USB 7/1/2) printers implement a simple PJL interpreter and generateproper responses, which also needs to be implemented in the io.ReadWriter interface withfunctionality enough to make CUPS happy.\n\nFocus Areas\n● Understanding the already implemented parts of the legacy printer simulation\n● Understanding the relevant documents formats in details enough to be able to perform the automatic format identification and to detect page or job boundaries\n● Understanding PJL in details enough to be able to process commands generated by CUPS and provide a proper responses\n\nStudent Contribution Guide\nThe contributor should study how the legacy printer works, how the graphical documents aresent to the printer and how the printer recognizes that document transmission is finished. Theprinted documents need to be extracted from the unstructured host to printer data flow andpassed separately to the upper layer, which will decide what to do with these documents (just tosave to the log file, to render etc).\nRendering of printed documents is out of the scope of this project, so very detailedunderstanding of the relevant formats is not required.\nAlso, for the implementation of the bidirectional (USB 7/1/2) printers the contributor needs tounderstand the behaviour expectations, based on specifications and CUPS implementation andto write a simple simulator.\nThe representation of the emulated printer as a virtual USB device already done in the go-mfpand out of scope of this project. At this level the contributor needs only to implement the Goio.Reader and io.ReadWriter interfaces that can properly consume the data sent to the printerand to generate the proper response, the task of transporting this data from/to the host is out ofscope of this project (and already solved at the first glance).\nAs result of this project, the code contribution into the go-mfp is expected, with the reasonabletest coverage and integration with the “big project”.",
    "techstack": ["Go", "C"],
    "github": "https://github.com/OpenPrinting/go-mfp",
    "mentors": [
      {
        "name": "Alexander Pevzner",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/alexander-pevzner-6046161/",
          "discord": "",
          "email": "pzz@apevzner.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "go-mfp escl IEEE",
    "developer": "Open Printing",
    "desc": "Adding the legacy IEEE-1284 printers support to go-mft in OpenPrinting\n\nProblem statement\nCurrently, the go-mfp simulator already has very basic support of the legacy USB 7/1/1 printeremulation. However, it doesn’t somehow interpret the data sent to the emulated printer anddoesn’t provide any response (as 7/1/2 devices should do).\nThe project goal is to implement the Go io.Reader (for 7/1/1 devices) and Go io.ReadWriter thatconsumes raw data bytes, sent to the emulated printer and able to properly identify documentformat being sent (i.e., PostScript, PDF, PCL5, ESC/P, ...) and based on that identificationproperly detect the document or page boundaries (for example, PostScript and PDF documentsare terminated by the Ctrl-D character, ESC/P and PCL5 may use end-of-page character etc).\nHaving that implemented we can add saving documents to file for further analysis andtroubleshooting and document rendering for printed image evaluation.\nAlso, the bidirectional (USB 7/1/2) printers implement a simple PJL interpreter and generateproper responses, which also needs to be implemented in the io.ReadWriter interface withfunctionality enough to make CUPS happy.\n\nFocus Areas\n● Understanding the already implemented parts of the legacy printer simulation\n● Understanding the relevant documents formats in details enough to be able to perform the automatic format identification and to detect page or job boundaries\n● Understanding PJL in details enough to be able to process commands generated by CUPS and provide a proper responses\n\nStudent Contribution Guide\nThe contributor should study how the legacy printer works, how the graphical documents aresent to the printer and how the printer recognizes that document transmission is finished. Theprinted documents need to be extracted from the unstructured host to printer data flow andpassed separately to the upper layer, which will decide what to do with these documents (just tosave to the log file, to render etc).\nRendering of printed documents is out of the scope of this project, so very detailedunderstanding of the relevant formats is not required.\nAlso, for the implementation of the bidirectional (USB 7/1/2) printers the contributor needs tounderstand the behaviour expectations, based on specifications and CUPS implementation andto write a simple simulator.\nThe representation of the emulated printer as a virtual USB device already done in the go-mfpand out of scope of this project. At this level the contributor needs only to implement the Goio.Reader and io.ReadWriter interfaces that can properly consume the data sent to the printerand to generate the proper response, the task of transporting this data from/to the host is out ofscope of this project (and already solved at the first glance).\nAs result of this project, the code contribution into the go-mfp is expected, with the reasonabletest coverage and integration with the “big project”.",
    "techstack": ["Go", "C"],
    "github": "https://github.com/OpenPrinting/go-mfp/tree/master/proto/escl",
    "mentors": [
      {
        "name": "Alexander Pevzner",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/alexander-pevzner-6046161/",
          "discord": "",
          "email": "pzz@apevzner.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "pdfio",
    "developer": "Open Printing",
    "desc": "Implementing Form XObject Rendering in libpdfrip for OpenPrinting\n\nProblem statement\nlibpdfrip is a PDF renderer in development, aiming to be the first fully open, permissivelylicensed PDF renderer built on top of PDFio and using Cairo as its backend.\n\nA key missing feature for real-world PDFs is Form XObject (/Subtype /Form) rendering. FormXObjects are reusable content blocks (logos, icons, repeated UI elements, stamps, etc.) that arereferenced via the “Do” operator in content streams. Many production PDFs rely on forms toavoid duplicating vector content.\n\nCurrently, libpdfrip does not support Form XObjects.\n\nThis project aims to add Form XObject rendering support to libpdfrip, including lookup throughthe resource dictionary, proper graphics state handling, and recursive interpretation of formcontent streams, with a minimal test suite and demo tooling to validate the implementation.\n\nFocus Areas\n● Understand PDF Form XObjects in the PDF specification such as :/Subtype /Form, /BBox, /Matrix, /Resources, and content streams\n\nStudent Contribution Guide\nThe contributor will begin by setting up a local development environment for libpdfrip, buildingthe library and any existing demo tools. After this, they should study the basic structure of PDFfiles: how pages, resources, XObjects, and content streams are organized, and how differentelements are referenced and reused within a document.\n\nNext, the contributor should go through the PDFio documentation to understand how to accessPDF metadata and structure using the library’s APIs. This includes learning how to locatepages, resource dictionaries, XObjects, and content streams through PDFio.\n\nWith this foundation in place, the student can start with the implementation of the actual FormXObject rendering path: saving the current graphics state, applying the form’s transformationmatrix, clipping based on /BBox, recursively interpreting the form’s content stream with thecorrect resource dictionary, and finally restoring the graphics state. They will ensure that thesame form can be reused multiple times at different positions and scales, and add safeguardsagainst infinite recursion when forms reference each other.\n\nThis work can be submitted as a standalone module or contributed directly to the libpdfripcodebase. To validate the implementation, the contributor will have to create a small set ofsynthetic PDFs (manually or via a generator) that use Form XObjects for simple shapes andlogos, and add C tests or a lightweight test harness that renders these PDFs with libpdfrip (forexample, to PNG via Cairo) and checks for successful execution and basic correctness.",
    "techstack": ["C", "Shell Scripting"],
    "github": "https://github.com/michaelrsweet/pdfio",
    "mentors": [
      {
        "name": "Uddhav Phatak",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/uddhavphatak",
          "discord": "",
          "email": "uddhavphatak@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "libpdfrip",
    "developer": "Open Printing",
    "desc": "Implementing Form XObject Rendering in libpdfrip for OpenPrinting\n\nProblem statement\nlibpdfrip is a PDF renderer in development, aiming to be the first fully open, permissivelylicensed PDF renderer built on top of PDFio and using Cairo as its backend.\n\nA key missing feature for real-world PDFs is Form XObject (/Subtype /Form) rendering. FormXObjects are reusable content blocks (logos, icons, repeated UI elements, stamps, etc.) that arereferenced via the “Do” operator in content streams. Many production PDFs rely on forms toavoid duplicating vector content.\n\nCurrently, libpdfrip does not support Form XObjects.\n\nThis project aims to add Form XObject rendering support to libpdfrip, including lookup throughthe resource dictionary, proper graphics state handling, and recursive interpretation of formcontent streams, with a minimal test suite and demo tooling to validate the implementation.\n\nFocus Areas\n● Understand PDF Form XObjects in the PDF specification such as :/Subtype /Form, /BBox, /Matrix, /Resources, and content streams\n\nStudent Contribution Guide\nThe contributor will begin by setting up a local development environment for libpdfrip, buildingthe library and any existing demo tools. After this, they should study the basic structure of PDFfiles: how pages, resources, XObjects, and content streams are organized, and how differentelements are referenced and reused within a document.\n\nNext, the contributor should go through the PDFio documentation to understand how to accessPDF metadata and structure using the library’s APIs. This includes learning how to locatepages, resource dictionaries, XObjects, and content streams through PDFio.\n\nWith this foundation in place, the student can start with the implementation of the actual FormXObject rendering path: saving the current graphics state, applying the form’s transformationmatrix, clipping based on /BBox, recursively interpreting the form’s content stream with thecorrect resource dictionary, and finally restoring the graphics state. They will ensure that thesame form can be reused multiple times at different positions and scales, and add safeguardsagainst infinite recursion when forms reference each other.\n\nThis work can be submitted as a standalone module or contributed directly to the libpdfripcodebase. To validate the implementation, the contributor will have to create a small set ofsynthetic PDFs (manually or via a generator) that use Form XObjects for simple shapes andlogos, and add C tests or a lightweight test harness that renders these PDFs with libpdfrip (forexample, to PNG via Cairo) and checks for successful execution and basic correctness.",
    "techstack": ["C", "Shell Scripting"],
    "github": "https://github.com/OpenPrinting/libpdfrip",
    "mentors": [
      {
        "name": "Uddhav Phatak",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/uddhavphatak",
          "discord": "",
          "email": "uddhavphatak@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "redis operator",
    "developer": "OpsTree Global",
    "desc": "Problem Statement\nA golang based redis operator that willmake/oversee Redisstandalone/cluster/replication/sentinelmode setup on top of the Kubernetes.\n\nFocus Areas\nThe focus area will be backendcontroller development along withperformance optimization.\n\nStudent Contribution Guide (IdeaPage)\n• Backup & Restore CRD\n• Add a RedisBackup CR to trigger backups (e.g., using BGSAVE, snapshots, or RDB dumps).\n• Similarly, a RedisRestore CR to restore from snapshot.\n• Integrate with object storage (S3, GCS) for snapshot uploads.\n• Automated Certificate Management\n• Integrate with cert-manager to automate TLS certificates for Redis and Sentinel pods.\n• Support cert rotation.\n• Auto-Scaling\n• Add horizontal scaling logic: based on usage (memory, CPU, keyspace, throughput), operator can scale the number of replicas or shards.\n• Alternatively, integrate with Kubernetes Horizontal Pod Autoscaler (HPA) or a custom scaler.\n• Advanced Configuration Customization\n• Allow users to pass raw Redis config via CRD (configMap or embedded).\n• Support config version upgrades / migrations (managing rolling restarts when config changes happen).",
    "techstack": ["GoLang"],
    "github": "https://github.com/OT-CONTAINER-KIT/redis-operator",
    "mentors": [
      {
        "name": "Abhishek Dubey",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/abhishek-dubey-09b43ab6/",
          "discord": "iamabhishekdubey",
          "email": "abhishek.dubey@opstree.com",
          "twitter": ""
        }
      },
      {
        "name": "Shubham Gupta",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/shubham-gupta-8b1168244/",
          "discord": "shubamgupta6536",
          "email": "iamshubhamgupta200@gmail.com ",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "K8s Vault Webhook",
    "developer": "OpsTree Global",
    "desc": "Problem Statement\nk8s-vault-webhook is a Kubernetes admission webhook which listen for the events related to Kubernetes resources for injecting secret directly from secret manager to pod, secret, and configmap. The motive of creating this project is to provide a dynamic secret injection to containers/pods running inside Kubernetes from different secret managers for enhanced security.\n\nFocus Area\nThe focus should be to stabilize the existing secret manager integrations, along with new feature support for secret manager.\n\nStudent Contribution Guide\nSupport for more secret managers / backends: maybe add support for secret managers not yet supported, or improve existing ones.\n• Secrets versioning and rotation: introduce versioning of secrets, or periodic re-injection when secrets change in Vault.\n• Custom annotations or templating: allow more flexible templating for how secrets should be injected (e.g., naming conventions, path transformations).\n• RBAC / policy management UI or CRD: build a CRD or UI to manage which service accounts map to which Vault policies, instead of manual policy definitions.\n• Backup/reconciliation: maintain a reconciliation loop that ensures injected secrets remain up-to-date even after pod restarts, or if secret manager data changes.\n• Observability: expose metrics from the webhook (such as number of admission requests, failed injections, latency) via Prometheus.\n• Fault tolerance: handle cases when the secret manager is down, or when the webhook’s certificate expires, more gracefully.",
    "techstack": ["GoLang"],
    "github": "https://github.com/OT-CONTAINER-KIT/k8s-vault-webhook",
    "mentors": [
      {
        "name": "Abhishek Dubey",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/abhishek-dubey-09b43ab6/",
          "discord": "iamabhishekdubey",
          "email": "abhishek.dubey@opstree.com",
          "twitter": ""
        }
      },
      {
        "name": "Samyak Jain",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/samyyaakk",
          "discord": "samyyaakk",
          "email": "samyak.jain@opstree.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Logging Operator",
    "developer": "OpsTree Global",
    "desc": " Problem Statement\nA golang based operator to create and manage EFK (Elasticsearch, Fluentd, and Kibana) stack on Kubernetes \n\nFocus Area\n• Development of backend API features to support elasticsearch, fluentd, and kibana integration.\n\nStudent Contribution Guide\nSupport for Alternative Log Collectors / Forwarders\n• Add support for Fluent Bit as a daemonset collector + Fluentd / ES / other outputs. (Although some upstream logging operators use Fluent Bit + Fluentd; if not present, this is big.)\n• Support for Loki as a storage backend (instead of or in addition to Elasticsearch) or other outputs (S3, Kafka, etc.).\n• Automatic Scaling & Lifecycle Management\n• Add CR-driven scaling for Elasticsearch nodes (master / data / ingestion) based on resource usage.\n• Implement lifecycle management of indices: rollover, retention, deleteold-index policies via CRD (or enhance existing index lifecycle CR).\n• Secure Multi-Tenancy / Namespacing\n• Build better namespace isolation of logging pipelines: allow CR per namespace, or per team, with RBAC.\n• Add validation / policy CRs to enforce which namespaces can write to which logging pipeline, or limit ES resources per tenant.\n• Observability Enhancements\n• Expose metrics from the operator: reconciliation time, number of CRs, failures, etc., via Prometheus.\n• Build Grafana dashboards for EFK stack health (ES metrics, Fluentd throughput, Kibana usage).",
    "techstack": ["GoLang"],
    "github": "https://github.com/OT-CONTAINER-KIT/logging-operator",
    "mentors": [
      {
        "name": "Abhishek Dubey",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/abhishek-dubey-09b43ab6/",
          "discord": "iamabhishekdubey",
          "email": "abhishek.dubey@opstree.com",
          "twitter": ""
        }
      },
      {
        "name": "Samyak Jain",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/samyyaakk",
          "discord": "samyyaakk",
          "email": "samyak.jain@opstree.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "ReZygisk",
    "developer": "The PerformanC Organization",
    "desc": "Difficulty/Complex: Hard-medium/High-medium\n\nDetailed Project Description:\nZygote injection implementation, allowing to inject into Android application processes through injection into Zygote. Students are meant to improve the project's control flow by simplifying the codebase; Find better ways to implement some sub-system. E.g. ptrace injection; Improve project performance while maintaining its hiding capabilities.",
    "techstack": ["C", "C++"],
    "github": "https://github.com/PerformanC/ReZygisk",
    "mentors": [
      {
        "name": "Pedro",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/abhishek-dubey-09b43ab6/",
          "discord": "@pedro.js",
          "email": "pedroolimpio@proton.me",
          "twitter": ""
        }
      },
      {
        "name": "RainyXeon",
        "socials": {
          "linkedin": "",
          "discord": "@rainyxeon",
          "email": "rainyxeon@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Lucas",
        "socials": {
          "linkedin": "",
          "discord": "@1lucas1.apk",
          "email": "1lucas1apk@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "NodeLink",
    "developer": "The PerformanC Organization",
    "desc": "Difficulty/Complex: Medium\n\nDetailed Project Description:\nA standalone music node to allow Discord bots to easily interact with Discord Voice API and play audios from multiple different sources, being interacted via LavaLink API. Students are meant to improve the project's control flow; Implement new sources to be played; Add support to more audio codecs.",
    "techstack": ["JavaScript"],
    "github": "https://github.com/PerformanC/NodeLink",
    "mentors": [
      {
        "name": "Pedro",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/abhishek-dubey-09b43ab6/",
          "discord": "@pedro.js",
          "email": "pedroolimpio@proton.me",
          "twitter": ""
        }
      },
      {
        "name": "RainyXeon",
        "socials": {
          "linkedin": "",
          "discord": "@rainyxeon",
          "email": "rainyxeon@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Lucas",
        "socials": {
          "linkedin": "",
          "discord": "@1lucas1.apk",
          "email": "1lucas1apk@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "TranscribeIt",
    "developer": "FOSSIA",
    "desc": "Problem Statement:\nHard of hearing and speech population, people with visual impairments and sensory processing disorders have difficulty navigating video content. With online platforms providing little to no transcriptions or inaccurate transcriptions, especially for live streams, it hinders acccessibility. TransribeIt aims to provide customized and diarized transcriptions for making video content accessible.\n\nFocus Areas:\n• Backend: API development, asynchronous processing, ASR (automatic speech recognition), diariazation, video processing\n• Frontend: Accessibility testing and UI development\n• Deployment: Containerized deployment, monitoring, performance optimization\n• Documentation: Onboarding instructions for developers, technical documentation\n\nStudent Contribution Guide:\n1. Backend Contributions\n\t• Optimize ASR pipelines for both pre-recorded videos and live streams from local content.\n\t• Integrate speaker diarization for multi-speaker videos with customization for speaker identification.\n\t• Streamline asynchronous video processing workflows using Python and FastAPI for real-world usage.\n\t• Provide alternative formats for exporting transcripts and streamline transcript generation\n\nExpected Outcomes:\n• Robust backend capable of handling multiple video formats and live streams.\n• Efficient, accurate transcription with speaker labels in customized manner\n• Formats such as Markdown, PDF and JSON for exports.\n\n2. Frontend Contributions\n• Develop an accessible UI using Next.js and Chakra UI for the features described in backend section.\n• Implement features such as searchable transcripts, speaker highlighting, transcript exporting and timestamps for accessibility.\n• Perform accessibility testing (screen readers, keyboard navigation, color contrast) and integrate accessibility focused tooling for WCAG compliance.\n• Create a responsive design for desktop and mobile.\n\nExpected Outcomes:\n• User-friendly interface for uploading videos and viewing transcriptions and providing URLs.\n• Improved accessibility for users with visual and hearing impairments.\n• Enhanced user experience with intuitive navigation and customization options.\n\n3. Deployment Contributions\n• Set up orchestration using Docker Compose for self-hosting by optimizing existing Docker setup.\n• Implement monitoring for system health and performance metrics for production.\n• Optimize backend performance for large video files or multiple concurrent live streams.\n\nExpected Outcomes:\n• Easy-to-deploy, scalable system for developers and end-users.\n• Improved stability and uptime.\n• Clear deployment guides for development and production environments.\n\n4. Documentation Contributions\n• Write technical documentation for technical implementation in an\nintegrated manner.\n• Create developer onboarding guides, including setup instructions.\n• Document API endpoints and video processing workflows using Swagger and VitePress\n• Maintain changelogs and contribution guidelines for future developers.\n\nExpected Outcomes:\n• Well-documented codebase for future contributors.\n• Reduced onboarding time for new developers.\n• Clear usage instructions for both developers and end-users. Milestones\n\n1. Milestone 1 – Setup & Familiarization\n• Set up local development environment (Docker, FastAPI, Next.js)\n• Explore existing codebase and documentation\n\n2. Milestone 2 – Core Backend Development\n• Create endpoints for video transcriptions in aternative formats\n• Optimize video transcription for larger videos\n• Implement speaker diarization with customisations\n\n3. Milestone 3 – Frontend Integration\n• Display transcription results with timestamps and speaker information\n• Develop user interface for exporting transcripts in prefered format\n\n4. Milestone 4 – Deployment & Monitoring\n• Containerize application for self-hosting and optimize existing Docker setup\n• Add logging, monitoring, and performance optimization for observability\n\n5. Milestone 6 – Documentation & Final Touches\n• Complete developer guide\n• Conduct accessibility testing",
    "techstack": ["FastAPI", "Python", "Docker", "Next.js", "Chakra UI"],
    "github": "https://github.com/fossiaorg/transcribeit",
    "mentors": [
      {
        "name": "Keerthana Rajesh Kumar",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/abhishek-dubey-09b43ab6/",
          "discord": "grittypuffy",
          "email": "grittypuffy@riseup.net",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Ak-dskit (DsKit)",
    "developer": "Programmer's Paradise",
    "desc": "Data scientists and ML engineers often spend 60-80% of their time on repetitive tasks like data cleaning, EDA, preprocessing, and basic modeling. There&#39;s a need for a unified, production-ready toolkit that wraps complex operations into simple 1-line commands while maintaining flexibility and comprehensive feature coverage. Ak-dskit solves this by providing 221+ wrapper functions that streamline the entire ML pipeline - from data loading to model deployment - making data science accessible, efficient, and production-ready.\n\nFocus Areas:\nStudents can contribute to various aspects of the project:\n\nCore Features Enhancement\n Extending data cleaning and preprocessing capabilities\n Adding new feature engineering methods\n Improving automated EDA functions\n Enhancing model validation utilities\n Visualization &amp; Explainability\n Creating new interactive visualization functions\n Improving SHAP integration for model explainability\n Building custom plotting utilities for specific use cases\n Developing hyperplane visualization for advanced algorithms\n AutoML &amp; Optimization\n Expanding hyperparameter tuning capabilities\n Adding support for new ML algorithms\n Implementing ensemble methods\n Building automated feature selection tools\n Documentation &amp; Testing\n Writing comprehensive tutorials and guides\n Creating Jupyter notebook examples\n Developing unit tests for existing functions\n Improving API documentation\n DevOps &amp; Deployment\n Setting up CI/CD pipelines\n Creating Docker containers for deployment\n Building model serving utilities\n Implementing monitoring and logging features\n Database &amp; Time Series\n Enhancing database utility functions\n Expanding time series analysis capabilities\n Adding support for new data sources\n Building data versioning tools\n Student Contribution Guide (Idea Page)\n\nWhat Students Will Work On:\n Beginner Level:\n\t1. Writing documentation and tutorials\n\t2. Creating example notebooks\n\t3. Adding unit tests for existing functions\n\t4. Fixing bugs and improving error handling\n\n5. Enhancing function docstrings\n Intermediate Level:\n\t1. Implementing new preprocessing methods\n\t2. Adding visualization functions\n\t3. Creating data validation utilities\n\t4. Building feature engineering tools\n\t5. Developing data profiling capabilities\n\n Advanced Level:\n\t1. Implementing advanced AutoML features\n\t2. Building custom ML algorithms\n\t3. Creating model deployment pipelines\n\t4. Developing distributed computing support\n\t5. Implementing neural network wrappers\n\nExpected Outcomes:\n1. At least 10-15 new utility functions added to the library\n2. Comprehensive test coverage (target: &gt;80%)\n3. 5+ tutorial notebooks demonstrating real-world use cases\n4. Improved documentation with API reference updates\n5. Performance optimization for core functions\n6. New features like automated report generation, data drift detection, or A/B testing utilities",
    "techstack": ["Python", "NumPy", "Pandas", "Scikit-learn", "Matplotlib", "Seaborn", "Plotly", "SHAP", "XGBoost", "LightGBM", "CatBoost", "Optuna", "Hyperopt", "PyPI"],
    "github": "https://github.com/Programmers-Paradise/DsKit",
    "mentors": [
      {
        "name": "Aksh Agrawal",
        "socials": {
          "linkedin": "www.linkedin.com/in/akshagr10",
          "discord": "hextrovert_10",
          "email": "aksh.300012824005@csvtu.ac.in",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Annie",
    "developer": "Programmer's Paradise",
    "desc": "Problem Statement:\nA lightning-fast, Rust-powered Approximate Nearest Neighbour library for Python with multiple backends, thread-safety, and GPU acceleration.\n\nFocus Area:\nStudent need to work on &quot; issues &quot; present in the repository.\n\nCore Features:\n Multiple Backends:\n\to Brute-force (exact) with SIMD acceleration\n\to HNSW (approximate) for large-scale datasets\n Multiple Distance Metrics: Euclidean, Cosine, Manhattan, Chebyshev\n Batch Queries for efficient processing\n Thread-safe indexes with concurrent access\n Zero-copy NumPy integration\n On-disk Persistence with serialization\n Filtered Search with custom Python callbacks\n GPU Acceleration for brute-force calculations\n Multi-platform support (Linux, Windows, macOS)\n Automated CI with performance tracking",
    "techstack": ["Rust" , "PyO3", "Python", "Machine Learning"],
    "github": "https://github.com/Programmers-Paradise/Annie",
    "mentors": [
      {
        "name": "Aksh Agrawal",
        "socials": {
          "linkedin": "www.linkedin.com/in/akshagr10",
          "discord": "hextrovert_10",
          "email": "aksh.300012824005@csvtu.ac.in",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Exsh",
    "developer": "RootSprout",
    "desc": "Focus Area:\n- Students can learn built from scratch implementations.\n- Everything is built in low level language (C), no abstraction.",
    "techstack": ["C"],
    "github": "https://github.com/RootSprout/Exsh",
    "mentors": [
      {
        "name": "Meerthika S R",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "rootsprout1@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Vinoth kumar",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "rootsprout1@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "CTP - A Serial datalink transport protocol",
    "developer": "RootSprout",
    "desc": "Focus Area:\n- Students can learn built from scratch implementations.\n- Everything is built in low level language (C), no abstraction.",
    "techstack": ["C"],
    "github": "https://github.com/RootSprout/CTP",
    "mentors": [
      {
        "name": "Meerthika S R",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "rootsprout1@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Vinoth kumar",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "rootsprout1@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Kira-Kafka",
    "developer": "RootSprout",
    "desc": "Focus Area:\n- Students can learn built from scratch implementations.\n- Everything is built in low level language (C), no abstraction.",
    "techstack": ["C"],
    "github": "https://github.com/RootSprout/Kira-Kafka",
    "mentors": [
      {
        "name": "Meerthika S R",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "rootsprout1@gmail.com",
          "twitter": ""
        }
      },
      {
        "name": "Vinoth kumar",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "rootsprout1@gmail.com",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "AMRIT",
    "developer": "PSMRI",
    "desc": "Any proposal guidelines, ideas, or focus areas for students.\nAMRIT is an EHR platform. Students will get exposure to healthcare domain and technology that powers grass root level operations in different parts of India. We will file issues under the GitHub issues section. Let me know if there is any template for filing these issues.",
    "techstack": ["TypeScript",  "Java",  "JavaScript", "Python",  "Kotlin"],
    "github": "https://github.com/PSMRI/AMRIT/",
    "mentors": [
      {
        "name": "Dr. Mithun James",
        "socials": {
          "linkedin": "",
          "discord": "",
          "email": "mithun.james@piramalswasthya.org",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  },
  {
    "name": "Keploy Blog Website",
    "developer": "Keploy",
    "desc": "● Problem Statement\nWe’re looking to improve the current Keploy blog website. There are several issues already listed in the Keploy repository, please pick one and start working on it. You’re also encouraged to create new issues by taking inspiration from other blog websites and suggesting improvements. The end goal is to enhance the blog website in terms of both UI and performance.\n\n● Focus Areas\nExample: backend API development, UI/UX improvements, documentation, performance optimization, devops.\n\n● Student Contribution Guide (Idea Page)\nFirst, please visit our repository and pick an issue to work on from the list below:\n\nIssues:\nhttps://github.com/keploy/keploy/issues?q=is%3Aissue%20state%3Aopen%20label%3Ablog-website\n\n● You’re also welcome to create a new issue if you have ideas or improvements you’d like to work on.\n\nNote: Please attach a short video of your changes so mentors can review them easily and share feedback quickly.",
    "techstack": ["TypeScript",  "JavaScript", "Wordpress"],
    "github": "https://github.com/keploy/blog-website",
    "mentors": [
      {
        "name": "Amaan bhati",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/amaan-bhati/",
          "discord": "amaan_bhati",
          "email": "amaan.bhati@keploy.io",
          "twitter": ""
        }
      },
      {
        "name": "Hermione Dadheech",
        "socials": {
          "linkedin": "https://www.linkedin.com/in/hermione-dadheech/",
          "discord": "hermione_dadheech_66979",
          "email": "hermione.dadheech@keploy.io",
          "twitter": ""
        }
      }
    ],
    "socials": {
      "linkedin": "",
      "discord": "",
      "email": "",
      "twitter": ""
    }
  }
]